** How to Write Tests **

- At its simplest, a test in Rust is a function that’s annotated with the test attribute.

- Attributes are metadata about pieces of Rust code; one example is the derive attribute we used with structs in Chapter 5.

- To change a function into a test function, add #[test] on the line before fn. Run your tests with the cargo test command.

- Can use assert_eq! or assert_ne! for testing equality or inequality vs using == within an assert statement

- We can write custom messages for assertions

- We can denote a test is expected to fail with should_panic

- You can’t use the #[should_panic] annotation on tests that use Result<T, E>.

- To assert that an operation returns an Err variant, don’t use the question mark operator on the Result<T, E> value. Instead, use assert!(value.is_err()).

** Controlling How Tests Are Run **

- Cargo test compiles all tests and runs them in parellel by default

- We must be careful when doing the default parellelism as if multiple tests interact with the same environment this can cause issues (like mutex locks)

- You can avoid running in parellel with the test flag -- --test-threads=1

- To see print statements of passing tests (doesnt show by default) use -- --show-output

- We can pass the name of any individual test to only run that test ex: cargo test function_name

- We can filter and run tests of similiar names for example if tests start with test_pems and we only want to run pems test: cargo test test_pems

- We can ignore expensive tests by adding the following #[ignore] attribute after #[test]

- On the flip side we can run only ignored tests with cargo test -- --ignored

** Test Organization **

- The main rust concensus is to split tests into unit tests and integration tests

- Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. 

- Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.

- The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected.

- You’ll put unit tests in the src directory in each file with the code that they’re testing.

- The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test).

- The #[cfg(test)] annotation on the tests module tells Rust to compile and run the test code only when you run cargo test

- There’s debate within the testing community about whether or not private functions should be tested directly

- Rust’s privacy rules do allow you to test private functions. 

- We create a tests directory at the top level of our project directory, next to src. Cargo knows to look for integration test files in this directory. 

- We can run a specific integration test using cargo test --test integration_test

- Because each module in /tests is treated as its own crate we would want to use a /tests/common/mod.rs to store setup utilities for tests